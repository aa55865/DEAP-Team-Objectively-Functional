import time, array, random, copy, math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from deap import algorithms, base, benchmarks, tools, creator

creator.create("FitnessMin", base.Fitness, weights=(-1.0,-1.0)) #creates Fitness class, assigns weights to objective(s) used to determine an individual's fitness
creator.create("Individual", array.array, typecode='d', fitness=creator.FitnessMin) #creates Individual class (type = array) with a fitness attribute

def solHX(individual): ### this algorithm calculates objective function values from individual values to determine fitness
	m_dot = 0.2
	q = 1000
	f = 0.04
	rho = 997.1
	cp = 4200
	c = 0.02
	g = 9.8
	Lsnum1 = 6*m_dot*cp/q
	Lsnum2 = math.pi*individual[0]*(1.5*individual[0]+0.5*c)+(individual[1]-1)*0.25*(math.pi**2)*((1.5*individual[0])**2-(0.5*individual[0])**2)
	Ls = (Lsnum1-Lsnum2)/(math.pi*individual[0]*individual[1])
	s = (8*f/(math.pi**2*g))*((m_dot/rho)**2/(individual[0]**5))
	Leff = Ls*individual[1]+(3*individual[0]+c)+50*individual[0]*(individual[1]-1)
	hloss = s*Leff
	henc = individual[0]+c
	wenc = individual[0]*individual[1]+individual[0]*(individual[1]-1)+c
	lenc = Ls + 3*individual[0] + c
	vol = lenc*wenc*henc
	if lenc > 1.5:
		vol,hloss = 100, 100
	return vol, hloss, lenc


toolbox = base.Toolbox() # "the toolbox is a container for all the tools selected by the user" - DEAP documentation
BOUND_LOW, BOUND_UP = 0.02,100
NDIM = 2
toolbox.register("evaluate", solHX) #registers the 'evaluate' alias in the toolbox, which refers to the solHX function

###General form of 'register': register(alias, method[, argument[, ...]])###
'''Parameters:	
alias – The name the operator will take in the toolbox. If the alias already exist it will overwrite the the operator already present.
method – The function to which the alias refers.
argument – One or more argument (and keyword argument) to pass automatically to the registered function when called, optional.'''


def uniform(low, up, size=None): ###this function creates random floats between 'low' and 'up'
    try:
        return [random.uniform(a, b) for a, b in zip(low, up)]
    except TypeError:
        return [random.uniform(a, b) for a, b in zip([low] * size, [up] * size)]

###sets the type and range of values contained in each individual###
toolbox.register("attr_float", uniform, BOUND_LOW, BOUND_UP, NDIM) #attr_float refers to function uniform, with args B_LOW,B_UP,NDIM

###registers the tool to create individuals (used by calling, for example, ind1 = toolbox.individual())###
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.attr_float) #individual refers to function initIterate, with args c.Ind & tool.attr_float

###registers the tool to create a population of individuals (used by calling, for example, pop1 = toolbox.population(n=popsize))###
toolbox.register("population", tools.initRepeat, list, toolbox.individual) #population referst to func initRepeat, with args list and tool.individual

###creates population distributed as a mesh###
num_samples = 50
limits = [np.arange(BOUND_LOW, BOUND_UP, (BOUND_UP - BOUND_LOW)/num_samples)] * NDIM
sample_x = np.meshgrid(*limits)
flat = []
for i in range(len(sample_x)):
    x_i = sample_x[i]
    flat.append(x_i.reshape(num_samples**NDIM))
example_pop = toolbox.population(n=num_samples**NDIM)
for i, ind in enumerate(example_pop):
    for j in range(len(flat)):
        ind[j] = flat[j][i]
    if ind[0] > 0.12:
    	ind[0] = random.uniform(0.02,0.12)
    if ind[1] is not 'int':
    	ind[1] = random.randint(1,400)

###set fitness values for all individuals in the population###
fitnesses = toolbox.map(toolbox.evaluate, example_pop)
for ind, fit in zip(example_pop, fitnesses):
    ind.fitness.values = fit

non_dom = tools.sortNondominated(example_pop, k=len(example_pop), first_front_only=True)[0]


for ind in non_dom:
    plt.plot(ind.fitness.values[0], ind.fitness.values[1], 'bo')
plt.title('Solar HX Pareto front')
plt.xlabel('Volume [m^3]')
plt.ylabel('Head Loss [m]')
plt.show()
